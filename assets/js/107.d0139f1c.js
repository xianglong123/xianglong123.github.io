(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{775:function(n,s,a){"use strict";a.r(s);var e=a(0),t=Object(e.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"juc集合-concurrenthashmap详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#juc集合-concurrenthashmap详解"}},[n._v("#")]),n._v(" JUC集合:ConcurrentHashMap详解")]),n._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[n._v("提示")]),n._v(" "),s("p",[n._v("JDK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。 @123")])]),n._v(" "),s("ul",[s("li",[n._v("JUC集合: ConcurrentHashMap详解\n"),s("ul",[s("li",[n._v("带着BAT大厂的面试问题去理解")]),n._v(" "),s("li",[n._v("为什么HashTable慢")]),n._v(" "),s("li",[n._v("ConcurrentHashMap - JDK 1.7\n"),s("ul",[s("li",[n._v("数据结构")]),n._v(" "),s("li",[n._v("初始化")]),n._v(" "),s("li",[n._v("put 过程分析")]),n._v(" "),s("li",[n._v("初始化槽: ensureSegment")]),n._v(" "),s("li",[n._v("获取写入锁: scanAndLockForPut")]),n._v(" "),s("li",[n._v("扩容: rehash")]),n._v(" "),s("li",[n._v("get 过程分析")]),n._v(" "),s("li",[n._v("并发问题分析")])])]),n._v(" "),s("li",[n._v("ConcurrentHashMap - JDK 1.8\n"),s("ul",[s("li",[n._v("数据结构")]),n._v(" "),s("li",[n._v("初始化")]),n._v(" "),s("li",[n._v("put 过程分析")]),n._v(" "),s("li",[n._v("初始化数组: initTable")]),n._v(" "),s("li",[n._v("链表转红黑树: treeifyBin")]),n._v(" "),s("li",[n._v("扩容: tryPresize")]),n._v(" "),s("li",[n._v("数据迁移: transfer")]),n._v(" "),s("li",[n._v("get 过程分析")])])]),n._v(" "),s("li",[n._v("对比总结")]),n._v(" "),s("li",[n._v("参考文章")])])])]),n._v(" "),s("h3",{attrs:{id:"带着bat大厂的面试问题去理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#带着bat大厂的面试问题去理解"}},[n._v("#")]),n._v(" # 带着BAT大厂的面试问题去理解")]),n._v(" "),s("blockquote",[s("p",[n._v("提示")])]),n._v(" "),s("blockquote",[s("p",[n._v("请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。@123")])]),n._v(" "),s("ul",[s("li",[n._v("为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?")]),n._v(" "),s("li",[n._v("ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.7说说其put的机制?")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容)")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.8是如何扩容的? tryPresize")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?")]),n._v(" "),s("li",[n._v("ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfer")])]),n._v(" "),s("h3",{attrs:{id:"为什么hashtable慢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么hashtable慢"}},[n._v("#")]),n._v(" # 为什么HashTable慢")]),n._v(" "),s("blockquote",[s("p",[n._v("Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。")])]),n._v(" "),s("h3",{attrs:{id:"concurrenthashmap-jdk-1-7"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-jdk-1-7"}},[n._v("#")]),n._v(" # ConcurrentHashMap - JDK 1.7")]),n._v(" "),s("blockquote",[s("p",[n._v("在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.")])]),n._v(" "),s("blockquote",[s("p",[n._v("简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。接下来分析JDK1.7版本中ConcurrentHashMap的实现原理。")])]),n._v(" "),s("h3",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[n._v("#")]),n._v(" # 数据结构")]),n._v(" "),s("blockquote",[s("p",[n._v("整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表部分或一段的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了槽来代表一个 segment。")])]),n._v(" "),s("blockquote",[s("p",[n._v("简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。")])]),n._v(" "),s("blockquote",[s("p",[n._v("![](./JUC集合_ ConcurrentHashMap详解 _ Java 全栈知识体系_files/java-thread-x-concurrent-hashmap-1.png)")])]),n._v(" "),s("blockquote",[s("p",[s("code",[n._v("concurrencyLevel")]),n._v(": 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。")])]),n._v(" "),s("blockquote",[s("p",[n._v("再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。")])]),n._v(" "),s("h3",{attrs:{id:"初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[n._v("#")]),n._v(" # 初始化")]),n._v(" "),s("ul",[s("li",[s("blockquote",[s("p",[n._v("initialCapacity: 初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。")])])]),n._v(" "),s("li",[s("blockquote",[s("p",[n._v("loadFactor: 负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。")])])])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel > MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize < concurrencyLevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n\n    // initialCapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    // 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个\n    int c = initialCapacity / ssize;\n    if (c * ssize < initialCapacity)\n        ++c;\n    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap < c)\n        cap <<= 1;\n\n    // 创建 Segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    Segment<K,V> s0 =\n        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry<K,V>[])new HashEntry[cap]);\n    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n    // 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br")])]),s("blockquote",[s("p",[n._v("初始化完成，我们得到了一个 Segment 数组。")])]),n._v(" "),s("blockquote",[s("p",[n._v("我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:")])]),n._v(" "),s("ul",[s("li",[n._v("Segment 数组长度为 16，不可以扩容")]),n._v(" "),s("li",[n._v("Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容")]),n._v(" "),s("li",[n._v("这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍")]),n._v(" "),s("li",[n._v("当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到")])]),n._v(" "),s("h3",{attrs:{id:"put-过程分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put-过程分析"}},[n._v("#")]),n._v(" # put 过程分析")]),n._v(" "),s("blockquote",[s("p",[n._v("我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public V put(K key, V value) {\n    Segment<K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    //  计算 key 的 hash 值\n    int hash = hash(key);\n    //  根据 hash 值找到 Segment 数组中的位置 j\n    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，\n    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标\n    int j = (hash >>> segmentShift) & segmentMask;\n    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    // ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n    //  插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br")])]),s("blockquote",[s("p",[n._v("第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。")])]),n._v(" "),s("blockquote",[s("p",[n._v("Segment 内部是由 "),s("code",[n._v("数组+链表")]),n._v(" 组成的。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        // 这个是 segment 内部的数组\n        HashEntry<K,V>[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) & hash;\n        // first 是数组该位置处的链表的表头\n        HashEntry<K,V> first = entryAt(tab, index);\n\n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry<K,V> e = first;;) {\n            if (e != null) {\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry<K,V>(hash, key, value, first);\n\n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldValue;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br")])]),s("blockquote",[s("p",[n._v("整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。")])]),n._v(" "),s("blockquote",[s("p",[n._v("到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。")])]),n._v(" "),s("h3",{attrs:{id:"初始化槽-ensuresegment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化槽-ensuresegment"}},[n._v("#")]),n._v(" # 初始化槽: ensureSegment")]),n._v(" "),s("blockquote",[s("p",[n._v("ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。")])]),n._v(" "),s("blockquote",[s("p",[n._v("这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment<K,V> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n\n        // 初始化 segment[k] 内部的数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n\n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br")])]),s("blockquote",[s("p",[n._v("总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。")])]),n._v(" "),s("h3",{attrs:{id:"获取写入锁-scanandlockforput"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取写入锁-scanandlockforput"}},[n._v("#")]),n._v(" # 获取写入锁: scanAndLockForPut")]),n._v(" "),s("blockquote",[s("p",[n._v("前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。")])]),n._v(" "),s("blockquote",[s("p",[n._v("下面我们来具体分析这个方法中是怎么控制加锁的。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n\n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br")])]),s("blockquote",[s("p",[n._v("这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。")])]),n._v(" "),s("blockquote",[s("p",[n._v("这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。")])]),n._v(" "),s("h3",{attrs:{id:"扩容-rehash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩容-rehash"}},[n._v("#")]),n._v(" # 扩容: rehash")]),n._v(" "),s("blockquote",[s("p",[n._v("重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容，扩容后，容量为原来的 2 倍。")])]),n._v(" "),s("blockquote",[s("p",[n._v("首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。")])]),n._v(" "),s("blockquote",[s("p",[n._v("该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity << 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry<K,V>[] newTable =\n        (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘0..00011111’\n    int sizeMask = newCapacity - 1;\n\n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i < oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry<K,V> lastRun = e;\n                // idx 是当前链表的头节点 e 的新位置\n                int lastIdx = idx;\n\n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry<K,V> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br")])]),s("blockquote",[s("p",[n._v("这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?")])]),n._v(" "),s("blockquote",[s("p",[n._v("仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。")])]),n._v(" "),s("blockquote",[s("p",[n._v("我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。")])]),n._v(" "),s("h3",{attrs:{id:"get-过程分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-过程分析"}},[n._v("#")]),n._v(" # get 过程分析")]),n._v(" "),s("blockquote",[s("p",[n._v("相对于 put 来说，get 就很简单了。")])]),n._v(" "),s("ul",[s("li",[n._v("计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”")]),n._v(" "),s("li",[n._v("槽中也是一个数组，根据 hash 找到数组中具体的位置")]),n._v(" "),s("li",[n._v("到这里是链表了，顺着链表进行查找即可")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    //  hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    //  根据 hash 找到对应的 segment\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        //  找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br")])]),s("h3",{attrs:{id:"并发问题分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发问题分析"}},[n._v("#")]),n._v(" # 并发问题分析")]),n._v(" "),s("blockquote",[s("p",[n._v("现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。")])]),n._v(" "),s("blockquote",[s("p",[n._v("添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。")])]),n._v(" "),s("ul",[s("li",[n._v("put 操作的线程安全性。\n"),s("ul",[s("li",[n._v("初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。")]),n._v(" "),s("li",[n._v("添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。")]),n._v(" "),s("li",[n._v("扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。")])])]),n._v(" "),s("li",[n._v("remove 操作的线程安全性。\n"),s("ul",[s("li",[n._v("remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。")]),n._v(" "),s("li",[n._v('get 操作需要遍历链表，但是 remove 操作会"破坏"链表。')]),n._v(" "),s("li",[n._v("如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。")]),n._v(" "),s("li",[n._v("如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。")])])])]),n._v(" "),s("h3",{attrs:{id:"concurrenthashmap-jdk-1-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-jdk-1-8"}},[n._v("#")]),n._v(" # ConcurrentHashMap - JDK 1.8")]),n._v(" "),s("blockquote",[s("p",[n._v("在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。")])]),n._v(" "),s("h3",{attrs:{id:"数据结构-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-2"}},[n._v("#")]),n._v(" # 数据结构")]),n._v(" "),s("blockquote",[s("p",[n._v("![](./JUC集合_ ConcurrentHashMap详解 _ Java 全栈知识体系_files/java-thread-x-concurrent-hashmap-2.png)")])]),n._v(" "),s("blockquote",[s("p",[n._v("结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。")])]),n._v(" "),s("h3",{attrs:{id:"初始化-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化-2"}},[n._v("#")]),n._v(" # 初始化")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("// 这构造函数里，什么都不干\npublic ConcurrentHashMap() {\n}\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("blockquote",[s("p",[n._v("这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。")])]),n._v(" "),s("blockquote",[s("p",[n._v("sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。")])]),n._v(" "),s("h3",{attrs:{id:"put-过程分析-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put-过程分析-2"}},[n._v("#")]),n._v(" # put 过程分析")]),n._v(" "),s("blockquote",[s("p",[n._v("仔细地一行一行代码看下去:")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public V put(K key, V value) {\n    return putVal(key, value, false);\n}\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    // 得到 hash 值\n    int hash = spread(key.hashCode());\n    // 用于记录相应链表的长度\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果数组"空"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = initTable();\n\n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == MOVED)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helpTransfer(tab, f);\n\n        else { // 到这里就是说，f 是该位置的头节点，而且不为空\n\n            V oldVal = null;\n            // 获取数组该位置的头节点的监视器锁\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) { // 头节点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) { // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n\n            if (binCount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount >= TREEIFY_THRESHOLD)\n                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // \n    addCount(1L, binCount);\n    return null;\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br"),s("span",{staticClass:"line-number"},[n._v("67")]),s("br"),s("span",{staticClass:"line-number"},[n._v("68")]),s("br"),s("span",{staticClass:"line-number"},[n._v("69")]),s("br"),s("span",{staticClass:"line-number"},[n._v("70")]),s("br"),s("span",{staticClass:"line-number"},[n._v("71")]),s("br"),s("span",{staticClass:"line-number"},[n._v("72")]),s("br"),s("span",{staticClass:"line-number"},[n._v("73")]),s("br"),s("span",{staticClass:"line-number"},[n._v("74")]),s("br"),s("span",{staticClass:"line-number"},[n._v("75")]),s("br"),s("span",{staticClass:"line-number"},[n._v("76")]),s("br"),s("span",{staticClass:"line-number"},[n._v("77")]),s("br"),s("span",{staticClass:"line-number"},[n._v("78")]),s("br"),s("span",{staticClass:"line-number"},[n._v("79")]),s("br"),s("span",{staticClass:"line-number"},[n._v("80")]),s("br"),s("span",{staticClass:"line-number"},[n._v("81")]),s("br"),s("span",{staticClass:"line-number"},[n._v("82")]),s("br"),s("span",{staticClass:"line-number"},[n._v("83")]),s("br"),s("span",{staticClass:"line-number"},[n._v("84")]),s("br"),s("span",{staticClass:"line-number"},[n._v("85")]),s("br"),s("span",{staticClass:"line-number"},[n._v("86")]),s("br"),s("span",{staticClass:"line-number"},[n._v("87")]),s("br"),s("span",{staticClass:"line-number"},[n._v("88")]),s("br"),s("span",{staticClass:"line-number"},[n._v("89")]),s("br"),s("span",{staticClass:"line-number"},[n._v("90")]),s("br"),s("span",{staticClass:"line-number"},[n._v("91")]),s("br")])]),s("h3",{attrs:{id:"初始化数组-inittable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化数组-inittable"}},[n._v("#")]),n._v(" # 初始化数组: initTable")]),n._v(" "),s("blockquote",[s("p",[n._v("这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。")])]),n._v(" "),s("blockquote",[s("p",[n._v("初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('private final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 初始化的"功劳"被其他线程"抢去"了\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // DEFAULT_CAPACITY 默认初始容量是 16\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    // 初始化数组，长度为 16 或初始化时提供的长度\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    // 将这个数组赋值给 table，table 是 volatile 的\n                    table = tab = nt;\n                    // 如果 n 为 16 的话，那么这里 sc = 12\n                    // 其实就是 75 * n\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                // 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br")])]),s("h3",{attrs:{id:"链表转红黑树-treeifybin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表转红黑树-treeifybin"}},[n._v("#")]),n._v(" # 链表转红黑树: treeifyBin")]),n._v(" "),s("blockquote",[s("p",[n._v("前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private final void treeifyBin(Node<K,V>[] tab, int index) {\n    Node<K,V> b; int n, sc;\n    if (tab != null) {\n        // MIN_TREEIFY_CAPACITY 为 64\n        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n            // 后面我们再详细分析这个方法\n            tryPresize(n << 1);\n        // b 是头节点\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n            // 加锁\n            synchronized (b) {\n\n                if (tabAt(tab, index) == b) {\n                    // 下面就是遍历链表，建立一颗红黑树\n                    TreeNode<K,V> hd = null, tl = null;\n                    for (Node<K,V> e = b; e != null; e = e.next) {\n                        TreeNode<K,V> p =\n                            new TreeNode<K,V>(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    // 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin<K,V>(hd));\n                }\n            }\n        }\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br")])]),s("h3",{attrs:{id:"扩容-trypresize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩容-trypresize"}},[n._v("#")]),n._v(" # 扩容: tryPresize")]),n._v(" "),s("blockquote",[s("p",[n._v("如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。")])]),n._v(" "),s("blockquote",[s("p",[n._v("这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。")])]),n._v(" "),s("blockquote",[s("p",[n._v("这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) {\n    // c: size 的 5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size >>> 1) + 1);\n    int sc;\n    while ((sc = sizeCtl) >= 0) {\n        Node<K,V>[] tab = table; int n;\n\n        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab == null || (n = tab.length) == 0) {\n            n = (sc > c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if (table == tab) {\n                        @SuppressWarnings("unchecked")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = nt;\n                        sc = n - (n >>> 2); // 75 * n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n            }\n        }\n        else if (c <= sc || n >= MAXIMUM_CAPACITY)\n            break;\n        else if (tab == table) {\n            // 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs = resizeStamp(n);\n\n            if (sc < 0) {\n                Node<K,V>[] nt;\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex <= 0)\n                    break;\n                //  用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                //    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            //  将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)\n            //     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数\n            //  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs << RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        }\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br")])]),s("blockquote",[s("p",[n._v("这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。")])]),n._v(" "),s("blockquote",[s("p",[n._v("所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。")])]),n._v(" "),s("h3",{attrs:{id:"数据迁移-transfer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据迁移-transfer"}},[n._v("#")]),n._v(" # 数据迁移: transfer")]),n._v(" "),s("blockquote",[s("p",[n._v("下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。")])]),n._v(" "),s("blockquote",[s("p",[n._v("虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。")])]),n._v(" "),s("blockquote",[s("p",[n._v("此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。")])]),n._v(" "),s("blockquote",[s("p",[n._v("阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。")])]),n._v(" "),s("blockquote",[s("p",[n._v("第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n\n    // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16\n    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n\n    // 如果 nextTab 为 null，先进行一次初始化\n    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab == null) {\n        try {\n            // 容量翻倍\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        // nextTable 是 ConcurrentHashMap 中的属性\n        nextTable = nextTab;\n        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex = n;\n    }\n\n    int nextn = nextTab.length;\n\n    // ForwardingNode 翻译过来就是正在被迁移的 Node\n    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    //    所以它其实相当于是一个标志。\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n\n    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n\n    /*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     */\n\n    // i 是位置索引，bound 是边界，注意是从后往前\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n\n        // 下面这个 while 真的是不好理解\n        // advance 为 true 表示可以进行下一个位置的迁移了\n        //   简单理解结局: i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i >= bound || finishing)\n                advance = false;\n\n            // 将 transferIndex 值赋给 nextIndex\n            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                // 所有的迁移操作已经完成\n                nextTable = null;\n                // 将新的 nextTab 赋值给 table 属性，完成迁移\n                table = nextTab;\n                // 重新计算 sizeCtl: n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 75 倍\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n\n            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs << RESIZE_STAMP_SHIFT) + 2\n            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                // 任务结束，方法退出\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n\n                // 到这里，说明 (sc - 2) == resizeStamp(n) << RESIZE_STAMP_SHIFT，\n                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node<K,V> ln, hn;\n                    // 头节点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh >= 0) {\n                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        // 需要将链表一分为二，\n                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit = fh & n;\n                        Node<K,V> lastRun = f;\n                        for (Node<K,V> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new Node<K,V>(ph, pk, pv, ln);\n                            else\n                                hn = new Node<K,V>(ph, pk, pv, hn);\n                        }\n                        // 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树的迁移\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> lo = null, loTail = null;\n                        TreeNode<K,V> hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node<K,V> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode<K,V> p = new TreeNode<K,V>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        // 如果一分为二后，节点数小于等于6，那么将红黑树转换回链表\n                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc != 0) ? new TreeBin<K,V>(hi) : t;\n\n                        // 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br"),s("span",{staticClass:"line-number"},[n._v("67")]),s("br"),s("span",{staticClass:"line-number"},[n._v("68")]),s("br"),s("span",{staticClass:"line-number"},[n._v("69")]),s("br"),s("span",{staticClass:"line-number"},[n._v("70")]),s("br"),s("span",{staticClass:"line-number"},[n._v("71")]),s("br"),s("span",{staticClass:"line-number"},[n._v("72")]),s("br"),s("span",{staticClass:"line-number"},[n._v("73")]),s("br"),s("span",{staticClass:"line-number"},[n._v("74")]),s("br"),s("span",{staticClass:"line-number"},[n._v("75")]),s("br"),s("span",{staticClass:"line-number"},[n._v("76")]),s("br"),s("span",{staticClass:"line-number"},[n._v("77")]),s("br"),s("span",{staticClass:"line-number"},[n._v("78")]),s("br"),s("span",{staticClass:"line-number"},[n._v("79")]),s("br"),s("span",{staticClass:"line-number"},[n._v("80")]),s("br"),s("span",{staticClass:"line-number"},[n._v("81")]),s("br"),s("span",{staticClass:"line-number"},[n._v("82")]),s("br"),s("span",{staticClass:"line-number"},[n._v("83")]),s("br"),s("span",{staticClass:"line-number"},[n._v("84")]),s("br"),s("span",{staticClass:"line-number"},[n._v("85")]),s("br"),s("span",{staticClass:"line-number"},[n._v("86")]),s("br"),s("span",{staticClass:"line-number"},[n._v("87")]),s("br"),s("span",{staticClass:"line-number"},[n._v("88")]),s("br"),s("span",{staticClass:"line-number"},[n._v("89")]),s("br"),s("span",{staticClass:"line-number"},[n._v("90")]),s("br"),s("span",{staticClass:"line-number"},[n._v("91")]),s("br"),s("span",{staticClass:"line-number"},[n._v("92")]),s("br"),s("span",{staticClass:"line-number"},[n._v("93")]),s("br"),s("span",{staticClass:"line-number"},[n._v("94")]),s("br"),s("span",{staticClass:"line-number"},[n._v("95")]),s("br"),s("span",{staticClass:"line-number"},[n._v("96")]),s("br"),s("span",{staticClass:"line-number"},[n._v("97")]),s("br"),s("span",{staticClass:"line-number"},[n._v("98")]),s("br"),s("span",{staticClass:"line-number"},[n._v("99")]),s("br"),s("span",{staticClass:"line-number"},[n._v("100")]),s("br"),s("span",{staticClass:"line-number"},[n._v("101")]),s("br"),s("span",{staticClass:"line-number"},[n._v("102")]),s("br"),s("span",{staticClass:"line-number"},[n._v("103")]),s("br"),s("span",{staticClass:"line-number"},[n._v("104")]),s("br"),s("span",{staticClass:"line-number"},[n._v("105")]),s("br"),s("span",{staticClass:"line-number"},[n._v("106")]),s("br"),s("span",{staticClass:"line-number"},[n._v("107")]),s("br"),s("span",{staticClass:"line-number"},[n._v("108")]),s("br"),s("span",{staticClass:"line-number"},[n._v("109")]),s("br"),s("span",{staticClass:"line-number"},[n._v("110")]),s("br"),s("span",{staticClass:"line-number"},[n._v("111")]),s("br"),s("span",{staticClass:"line-number"},[n._v("112")]),s("br"),s("span",{staticClass:"line-number"},[n._v("113")]),s("br"),s("span",{staticClass:"line-number"},[n._v("114")]),s("br"),s("span",{staticClass:"line-number"},[n._v("115")]),s("br"),s("span",{staticClass:"line-number"},[n._v("116")]),s("br"),s("span",{staticClass:"line-number"},[n._v("117")]),s("br"),s("span",{staticClass:"line-number"},[n._v("118")]),s("br"),s("span",{staticClass:"line-number"},[n._v("119")]),s("br"),s("span",{staticClass:"line-number"},[n._v("120")]),s("br"),s("span",{staticClass:"line-number"},[n._v("121")]),s("br"),s("span",{staticClass:"line-number"},[n._v("122")]),s("br"),s("span",{staticClass:"line-number"},[n._v("123")]),s("br"),s("span",{staticClass:"line-number"},[n._v("124")]),s("br"),s("span",{staticClass:"line-number"},[n._v("125")]),s("br"),s("span",{staticClass:"line-number"},[n._v("126")]),s("br"),s("span",{staticClass:"line-number"},[n._v("127")]),s("br"),s("span",{staticClass:"line-number"},[n._v("128")]),s("br"),s("span",{staticClass:"line-number"},[n._v("129")]),s("br"),s("span",{staticClass:"line-number"},[n._v("130")]),s("br"),s("span",{staticClass:"line-number"},[n._v("131")]),s("br"),s("span",{staticClass:"line-number"},[n._v("132")]),s("br"),s("span",{staticClass:"line-number"},[n._v("133")]),s("br"),s("span",{staticClass:"line-number"},[n._v("134")]),s("br"),s("span",{staticClass:"line-number"},[n._v("135")]),s("br"),s("span",{staticClass:"line-number"},[n._v("136")]),s("br"),s("span",{staticClass:"line-number"},[n._v("137")]),s("br"),s("span",{staticClass:"line-number"},[n._v("138")]),s("br"),s("span",{staticClass:"line-number"},[n._v("139")]),s("br"),s("span",{staticClass:"line-number"},[n._v("140")]),s("br"),s("span",{staticClass:"line-number"},[n._v("141")]),s("br"),s("span",{staticClass:"line-number"},[n._v("142")]),s("br"),s("span",{staticClass:"line-number"},[n._v("143")]),s("br"),s("span",{staticClass:"line-number"},[n._v("144")]),s("br"),s("span",{staticClass:"line-number"},[n._v("145")]),s("br"),s("span",{staticClass:"line-number"},[n._v("146")]),s("br"),s("span",{staticClass:"line-number"},[n._v("147")]),s("br"),s("span",{staticClass:"line-number"},[n._v("148")]),s("br"),s("span",{staticClass:"line-number"},[n._v("149")]),s("br"),s("span",{staticClass:"line-number"},[n._v("150")]),s("br"),s("span",{staticClass:"line-number"},[n._v("151")]),s("br"),s("span",{staticClass:"line-number"},[n._v("152")]),s("br"),s("span",{staticClass:"line-number"},[n._v("153")]),s("br"),s("span",{staticClass:"line-number"},[n._v("154")]),s("br"),s("span",{staticClass:"line-number"},[n._v("155")]),s("br"),s("span",{staticClass:"line-number"},[n._v("156")]),s("br"),s("span",{staticClass:"line-number"},[n._v("157")]),s("br"),s("span",{staticClass:"line-number"},[n._v("158")]),s("br"),s("span",{staticClass:"line-number"},[n._v("159")]),s("br"),s("span",{staticClass:"line-number"},[n._v("160")]),s("br"),s("span",{staticClass:"line-number"},[n._v("161")]),s("br"),s("span",{staticClass:"line-number"},[n._v("162")]),s("br"),s("span",{staticClass:"line-number"},[n._v("163")]),s("br"),s("span",{staticClass:"line-number"},[n._v("164")]),s("br"),s("span",{staticClass:"line-number"},[n._v("165")]),s("br"),s("span",{staticClass:"line-number"},[n._v("166")]),s("br"),s("span",{staticClass:"line-number"},[n._v("167")]),s("br"),s("span",{staticClass:"line-number"},[n._v("168")]),s("br"),s("span",{staticClass:"line-number"},[n._v("169")]),s("br"),s("span",{staticClass:"line-number"},[n._v("170")]),s("br"),s("span",{staticClass:"line-number"},[n._v("171")]),s("br"),s("span",{staticClass:"line-number"},[n._v("172")]),s("br"),s("span",{staticClass:"line-number"},[n._v("173")]),s("br"),s("span",{staticClass:"line-number"},[n._v("174")]),s("br"),s("span",{staticClass:"line-number"},[n._v("175")]),s("br"),s("span",{staticClass:"line-number"},[n._v("176")]),s("br"),s("span",{staticClass:"line-number"},[n._v("177")]),s("br"),s("span",{staticClass:"line-number"},[n._v("178")]),s("br"),s("span",{staticClass:"line-number"},[n._v("179")]),s("br"),s("span",{staticClass:"line-number"},[n._v("180")]),s("br"),s("span",{staticClass:"line-number"},[n._v("181")]),s("br"),s("span",{staticClass:"line-number"},[n._v("182")]),s("br"),s("span",{staticClass:"line-number"},[n._v("183")]),s("br"),s("span",{staticClass:"line-number"},[n._v("184")]),s("br"),s("span",{staticClass:"line-number"},[n._v("185")]),s("br"),s("span",{staticClass:"line-number"},[n._v("186")]),s("br"),s("span",{staticClass:"line-number"},[n._v("187")]),s("br"),s("span",{staticClass:"line-number"},[n._v("188")]),s("br"),s("span",{staticClass:"line-number"},[n._v("189")]),s("br"),s("span",{staticClass:"line-number"},[n._v("190")]),s("br"),s("span",{staticClass:"line-number"},[n._v("191")]),s("br"),s("span",{staticClass:"line-number"},[n._v("192")]),s("br"),s("span",{staticClass:"line-number"},[n._v("193")]),s("br"),s("span",{staticClass:"line-number"},[n._v("194")]),s("br"),s("span",{staticClass:"line-number"},[n._v("195")]),s("br"),s("span",{staticClass:"line-number"},[n._v("196")]),s("br"),s("span",{staticClass:"line-number"},[n._v("197")]),s("br"),s("span",{staticClass:"line-number"},[n._v("198")]),s("br")])]),s("blockquote",[s("p",[n._v("说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。")])]),n._v(" "),s("blockquote",[s("p",[n._v("这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。")])]),n._v(" "),s("h3",{attrs:{id:"get-过程分析-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-过程分析-2"}},[n._v("#")]),n._v(" # get 过程分析")]),n._v(" "),s("blockquote",[s("p",[n._v("get 方法从来都是最简单的，这里也不例外:")])]),n._v(" "),s("ul",[s("li",[n._v("计算 hash 值")]),n._v(" "),s("li",[n._v("根据 hash 值找到数组对应位置: (n - 1) & h")]),n._v(" "),s("li",[n._v("根据该位置处结点性质进行相应查找\n"),s("ul",[s("li",[n._v("如果该位置为 null，那么直接返回 null 就可以了")]),n._v(" "),s("li",[n._v("如果该位置处的节点刚好就是我们需要的，返回该节点的值即可")]),n._v(" "),s("li",[n._v("如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法")]),n._v(" "),s("li",[n._v("如果以上 3 条都不满足，那就是链表，进行遍历比对即可")])])])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断头节点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n\n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("blockquote",[s("p",[n._v("简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。")])]),n._v(" "),s("h3",{attrs:{id:"对比总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比总结"}},[n._v("#")]),n._v(" # 对比总结")]),n._v(" "),s("ul",[s("li",[s("p",[s("code",[n._v("HashTable")]),n._v(" : 使用了synchronized关键字对put等操作进行加锁;")])]),n._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("ConcurrentHashMap JDK7\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v(": 使用分段锁机制实现;")])]),n._v(" "),s("li",[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("ConcurrentHashMap JDK8\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v(": 则使用数组+链表+红黑树数据结构和CAS原子操作实现;")])])]),n._v(" "),s("h3",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[n._v("#")]),n._v(" # 参考文章")]),n._v(" "),s("ul",[s("li",[n._v("https://blog.csdn.net/defonds/article/details/44021605#t7")]),n._v(" "),s("li",[n._v("http://tutorials.jenkov.com/java-concurrency/index.html")]),n._v(" "),s("li",[n._v("https://juejin.im/post/5aeeaba8f265da0b9d781d16")]),n._v(" "),s("li",[n._v("https://www.javadoop.com/post/hashmap#Java7%20ConcurrentHashMap")]),n._v(" "),s("li",[n._v("https://blog.csdn.net/Bill_Xiang_/article/details/81122044")]),n._v(" "),s("li",[n._v("https://www.cnblogs.com/leesf456/p/5453341.html")]),n._v(" "),s("li",[n._v("https://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html")])])])}),[],!1,null,null,null);s.default=t.exports}}]);