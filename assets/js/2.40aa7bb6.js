(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{355:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-6.cc54d991.png"},560:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-0.2143f412.png"},561:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-2.538fcca6.png"},562:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-1.8d6a29e6.png"},563:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-3.8ce7f377.png"},564:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-4.81db38da.png"},565:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-5.1367ca86.png"},566:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-visualvm-2.2005fa35.png"},567:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-visualvm-1.07da0183.png"},568:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-visualvm-3.8cca96e0.png"},569:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-visualvm-4.5bc54429.png"},570:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-tool-10.f005eda5.png"},571:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-18.bf7d5d18.png"},572:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-1.51cb361c.png"},573:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-2.471f414b.png"},574:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-3.b96229dd.png"},575:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-4.f33fcbf0.png"},576:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-5.d3fbbd60.png"},577:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-6.916830e0.png"},578:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-7.8b99f018.png"},579:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-8.666782de.png"},580:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-9.9ee0e9b5.png"},581:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-10.c6db428f.png"},582:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-14.a4717b07.png"},583:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-15.b91822a7.png"},584:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-16.7d3b4046.png"},585:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-jprofile-17.c086785c.png"},586:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-mat-2.7c148206.png"},587:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-mat-3.34efaa85.png"},588:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-mat-4.fe09c4a6.png"},589:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-mat-5.ddab9012.png"},590:function(t,a,s){t.exports=s.p+"assets/img/java-jvm-mat-6.7d4288cf.png"},765:function(t,a,s){"use strict";s.r(a);var o=s(0),e=Object(o.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"调试排错-java-问题排查之jvm可视化工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调试排错-java-问题排查之jvm可视化工具"}},[t._v("#")]),t._v(" 调试排错 - Java 问题排查之JVM可视化工具")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("本文主要梳理常见的JVM可视化的分析工具，主要包括JConsole, Visual VM, Vusial GC, JProfile 和 MAT等。 @123")])]),t._v(" "),a("ul",[a("li",[t._v("调试排错 - Java 问题排查之JVM可视化工具\n"),a("ul",[a("li",[t._v("JConsole")]),t._v(" "),a("li",[t._v("Visual VM")]),t._v(" "),a("li",[t._v("Visual GC")]),t._v(" "),a("li",[t._v("JProfile\n"),a("ul",[a("li",[t._v("核心组件")]),t._v(" "),a("li",[t._v("运行测试")])])]),t._v(" "),a("li",[t._v("Eclipse Memory Analyzer (MAT)")])])])]),t._v(" "),a("h3",{attrs:{id:"jconsole"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jconsole"}},[t._v("#")]),t._v(" # JConsole")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("Jconsole （Java Monitoring and Management Console），JDK自带的基于JMX的可视化监视、管理工具。 官方文档可以参考这里在新窗口打开")])])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("找到jconsole工具")])])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("pdai"),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@MacBook")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pro")]),t._v(" bin "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" ls\njaotc\t\tjcmd\t\tjinfo\t\tjshell\t\trmid\njar\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("jconsole")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("这里"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\tjjs\t\tjstack\t\trmiregistry\njarsigner\tjdb\t\tjlink\t\tjstat\t\tserialver\njava\t\tjdeprscan\tjmap\t\tjstatd\t\tunpack200\njavac\t\tjdeps\t\tjmod\t\tkeytool\njavadoc\t\tjhsdb\t\tjps\t\tpack200\njavap\t\tjimage\t\tjrunscript\trmic\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("ul",[a("li",[a("code",[t._v("打开jconsole")])])]),t._v(" "),a("blockquote",[a("p",[t._v("选择")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(560),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(561),alt:""}})])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("查看概述、内存、线程、类、VM概要、MBean")])])]),t._v(" "),a("blockquote",[a("p",[t._v("概述")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(562),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("内存")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(563),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("线程")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(564),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("类")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(565),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("VM概要")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(355),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("MBean")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(355),alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"visual-vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visual-vm"}},[t._v("#")]),t._v(" # Visual VM")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("VisualVM 是一款免费的，集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("Overview")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(566),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("Monitor")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(567),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("线程")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(568),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("Sampler")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(569),alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"visual-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visual-gc"}},[t._v("#")]),t._v(" # Visual GC")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("visual gc 是 visualvm 中的图形化查看 gc 状况的插件。官方文档可以参考这里在新窗口打开")])])]),t._v(" "),a("blockquote",[a("p",[t._v("比如我在IDEA中使用visual GC 插件来看GC状况。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(570),alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"jprofile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jprofile"}},[t._v("#")]),t._v(" # JProfile")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("Profiler 是一个商业的主要用于检查和跟踪系统（限于Java开发的）的性能的工具。JProfiler可以通过时时的监控系统的内存使用情况，随时监视垃圾回收，线程运行状况等手段，从而很好的监视JVM运行情况及其性能。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler 是一个全功能的Java剖析工具（profiler），专用于分析J2SE和J2EE应用程序。它把CPU、执行绪和内存的剖析组合在一个强大的应用中。 JProfiler可提供许多IDE整合和应用服务器整合用途。JProfiler直觉式的GUI让你可以找到效能瓶颈、抓出内存漏失(memory leaks)、并解决执行绪的问题。它让你得以对heap walker作资源回收器的root analysis，可以轻易找出内存漏失；heap快照（snapshot）模式让未被参照（reference）的对象、稍微被参照的对象、或在终结（finalization）队列的对象都会被移除；整合精灵以便剖析浏览器的Java外挂功能。")])]),t._v(" "),a("h3",{attrs:{id:"核心组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心组件"}},[t._v("#")]),t._v(" # 核心组件")]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler 包含用于采集目标 JVM 分析数据的 JProfiler agent、用于可视化分析数据的 JProfiler UI、提供各种功能的命令行工具，它们之间的关系如下图所示。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(571),alt:""}})])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("JProfiler agent")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler agent 是一个本地库，它可以在 JVM 启动时通过参数")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("agentpath"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("to")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" library"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("进行加载或者在程序运行时通过JVM Attach 机制在新窗口打开进行加载。Agent 被成功加载后，会设置 JVMTI 环境，监听虚拟机产生的事件，如类加载、线程创建等。例如，当它监听到类加载事件后，会给这些类注入用于执行度量操作的字节码。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("JProfiler UI")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler UI 是一个可独立部署的组件，它通过 socket 和 agent 建立连接。这意味着不论目标 JVM 运行在本地还是远端，JProfiler UI 和 agent 间的通信机制都是一样的。")])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler UI 的主要功能是展示通过 agent 采集上来的分析数据，此外还可以通过它控制 agent 的采集行为，将快照保存至磁盘，展示保存的快照。")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("命令行工具")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfiler 提供了一系列命令行工具以实现不同的功能。")])]),t._v(" "),a("ol",[a("li",[t._v("jpcontroller - 用于控制 agent 的采集行为。它通过 agent 注册的 JProfiler MBean 向 agent 传递命令。")]),t._v(" "),a("li",[t._v("jpenable - 用于将 agent 加载到一个正在运行的 JVM 上。")]),t._v(" "),a("li",[t._v("jpdump - 用于获取正在运行的 JVM 的堆快照。")]),t._v(" "),a("li",[t._v("jpexport & jpcompare - 用于从保存的快照中提取数据并创建 HTML 报告。")])]),t._v(" "),a("h3",{attrs:{id:"运行测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行测试"}},[t._v("#")]),t._v(" # 运行测试")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("我们运行一个SpringBoot测试工程，选择attach到JVM")])])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(572),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("选择指定的进程")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(573),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("设置数据采集模式")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JProfier 提供两种数据采集模式 Sampling 和 Instrumentation。")])]),t._v(" "),a("ul",[a("li",[t._v("Sampling - 适合于不要求数据完全精确的场景。优点是对系统性能的影响较小，缺点是某些特性不支持（如方法级别的统计信息）。")]),t._v(" "),a("li",[t._v("Instrumentation - 完整功能模式，统计信息也是精确的。缺点是如果需要分析的类比较多，对应用性能影响较大。为了降低影响，往往需要和 Filter 一起使用。")])]),t._v(" "),a("blockquote",[a("p",[t._v("由于我们需要获取方法级别的统计信息，这里选择了 Instrumentation 模式。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(574),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("概览")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(575),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("内存")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(576),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("实时内存分布（类对象）")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(577),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("dump 堆内存")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(578),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("dump完会直接打开显示")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(579),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("线程存储")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(580),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("导出HTML报告")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(581),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("CPU 调用树")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(582),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("线程历史")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(583),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("JEE & 探针")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(584),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("MBeans")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(585),alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"eclipse-memory-analyzer-mat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eclipse-memory-analyzer-mat"}},[t._v("#")]),t._v(" # Eclipse Memory Analyzer (MAT)")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("MAT 是一种快速且功能丰富的 Java 堆分析器，可帮助你发现内存泄漏并减少内存消耗。 MAT在的堆内存分析问题使用极为广泛，需要重点掌握。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("可以在这里在新窗口打开下载， 官方文档可以看这里在新窗口打开")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Overview")])])]),t._v(" "),a("blockquote",[a("p",[t._v("包含内存分布，以及潜在的问题推测")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(586),alt:""}})])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Histogram")])])]),t._v(" "),a("blockquote",[a("p",[t._v("可以列出内存中的对象，对象的个数以及大小。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(587),alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v("具体需要重点理解如下两个概念，可参考官网文档在新窗口打开的解释")])]),t._v(" "),a("ol",[a("li",[t._v("Shallow Heap ：一个对象内存的消耗大小，不包含对其他对象的引用")]),t._v(" "),a("li",[t._v("Retained Heap ：是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Dominator Tree")])])]),t._v(" "),a("blockquote",[a("p",[t._v("可以列出那个线程，以及线程下面的那些对象占用的空间。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(588),alt:""}})])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Top consumers")])])]),t._v(" "),a("blockquote",[a("p",[t._v("通过图形列出最大的object。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(589),alt:""}})])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Leak Suspects")])])]),t._v(" "),a("blockquote",[a("p",[t._v("自动分析潜在可能的泄漏。")])]),t._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:s(590),alt:""}})])])])}),[],!1,null,null,null);a.default=e.exports}}]);