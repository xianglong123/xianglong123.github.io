(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{456:function(s,n){s.exports="data:image/png;base64,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"},746:function(s,n,a){"use strict";a.r(n);var t=a(0),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"java-8-stampedlock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-8-stampedlock"}},[s._v("#")]),s._v(" Java 8 - StampedLock")]),s._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),n("p",[s._v("本文将从synchronized、Lock到Java8新增的StampedLock进行对比分析，相信StampedLock不会让大家失望。 @123")])]),s._v(" "),n("ul",[n("li",[s._v("Java 8 - StampedLock\n"),n("ul",[n("li",[s._v("synchronized")]),s._v(" "),n("li",[s._v("Lock")]),s._v(" "),n("li",[s._v("StampedLock")]),s._v(" "),n("li",[s._v("StampedLock与ReadWriteLock性能对比")]),s._v(" "),n("li",[s._v("总结")]),s._v(" "),n("li",[s._v("参考")])])])]),s._v(" "),n("h3",{attrs:{id:"synchronized"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[s._v("#")]),s._v(" # synchronized")]),s._v(" "),n("blockquote",[n("p",[s._v("在java5之前，实现同步主要是使用synchronized。它是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。")])]),s._v(" "),n("blockquote",[n("p",[s._v("有四种不同的同步块:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("实例方法\n静态方法\n实例方法中的同步块\n静态方法中的同步块\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("blockquote",[n("p",[s._v("大家对此应该不陌生，所以不多讲了，以下是代码示例")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("synchronized(this)\n// do operation\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("blockquote",[n("p",[s._v("小结: 在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，性能上也有所提升。")])]),s._v(" "),n("h3",{attrs:{id:"lock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lock"}},[s._v("#")]),s._v(" # Lock")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("rwlock.writeLock().lock();\ntry {\n\t// do operation\n} finally {\n\trwlock.writeLock().unlock();\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("blockquote",[n("p",[s._v("它是Java 5在java.util.concurrent.locks新增的一个API。")])]),s._v(" "),n("blockquote",[n("p",[s._v("Lock是一个接口，核心方法是lock()，unlock()，tryLock()，实现类有ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock；")])]),s._v(" "),n("blockquote",[n("p",[s._v("ReentrantReadWriteLock, ReentrantLock 和synchronized锁都有相同的内存语义。")])]),s._v(" "),n("blockquote",[n("p",[s._v("与synchronized不同的是，Lock完全用Java写成，在java这个层面是无关JVM实现的。Lock提供更灵活的锁机制，很多synchronized 没有提供的许多特性，比如锁投票，定时锁等候和中断锁等候，但因为lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中")])]),s._v(" "),n("blockquote",[n("p",[s._v("下面是Lock的一个代码示例")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  \t//下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\t//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0 && y == 0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br")])]),n("blockquote",[n("p",[s._v("小结: 比synchronized更灵活、更具可伸缩性的锁定机制，但不管怎么说还是synchronized代码要更容易书写些")])]),s._v(" "),n("h3",{attrs:{id:"stampedlock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stampedlock"}},[s._v("#")]),s._v(" # StampedLock")]),s._v(" "),n("blockquote",[n("p",[s._v("它是java8在java.util.concurrent.locks新增的一个API。")])]),s._v(" "),n("blockquote",[n("p",[s._v("ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(Pessimistic Reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。")])]),s._v(" "),n("blockquote",[n("p",[s._v("然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿(Starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。")])]),s._v(" "),n("blockquote",[n("p",[s._v("StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。")])]),s._v(" "),n("blockquote",[n("p",[s._v("所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量！！")])]),s._v(" "),n("blockquote",[n("p",[s._v("下面是java doc提供的StampedLock一个例子")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  //下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\t//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0 && y == 0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br")])]),n("blockquote",[n("p",[s._v("小结:")])]),s._v(" "),n("blockquote",[n("p",[s._v("StampedLock要比ReentrantReadWriteLock更加廉价，也就是消耗比较小。")])]),s._v(" "),n("h3",{attrs:{id:"stampedlock与readwritelock性能对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stampedlock与readwritelock性能对比"}},[s._v("#")]),s._v(" # StampedLock与ReadWriteLock性能对比")]),s._v(" "),n("blockquote",[n("p",[s._v("是和ReadWritLock相比，在一个线程情况下，是读速度其4倍左右，写是1倍。")])]),s._v(" "),n("blockquote",[n("p",[s._v("下图是六个线程情况下，读性能是其几十倍，写性能也是近10倍左右:")])]),s._v(" "),n("blockquote",[n("p",[n("img",{attrs:{src:a(456),alt:""}})])]),s._v(" "),n("h3",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" # 总结")]),s._v(" "),n("ul",[n("li",[s._v("synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定；")]),s._v(" "),n("li",[s._v("ReentrantLock、ReentrantReadWriteLock,、StampedLock都是对象层面的锁定，要保证锁定一定会被释放，就必须将unLock()放到finally{}中；")]),s._v(" "),n("li",[s._v("StampedLock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下；")]),s._v(" "),n("li",[s._v("StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法;")]),s._v(" "),n("li",[s._v("当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现;")]),s._v(" "),n("li",[s._v("当线程增长能够预估，ReentrantLock是一个很好的通用的锁实现;")])]),s._v(" "),n("blockquote",[n("p",[s._v("StampedLock 可以说是Lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前Lock的东西，毕竟他还是有些应用场景的，起码API比StampedLock容易入手。")])]),s._v(" "),n("h3",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" # 参考")]),s._v(" "),n("ul",[n("li",[n("blockquote",[n("p",[s._v("https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B%20Threads%20%E5%92%8C%20Executors.html")])])]),s._v(" "),n("li",[n("blockquote",[n("p",[s._v("https://wizardforcel.gitbooks.io/java8-new-features/content/10.html")])])])])])}),[],!1,null,null,null);n.default=e.exports}}]);