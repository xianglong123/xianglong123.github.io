(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{615:function(a,e,n){a.exports=n.p+"assets/img/java-thread-x-atomicinteger-unsafe.ecd3a0c9.png"},779:function(a,e,n){"use strict";n.r(e);var s=n(0),t=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"juc-类汇总和学习指南"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#juc-类汇总和学习指南"}},[a._v("#")]),a._v(" JUC - 类汇总和学习指南")]),a._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),e("p",[a._v("JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案; java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的。所以本章将对CAS, Unsafe和原子类详解。 @123")])]),a._v(" "),e("ul",[e("li",[a._v("JUC原子类: CAS, Unsafe和原子类详解\n"),e("ul",[e("li",[a._v("带着BAT大厂的面试问题去理解")]),a._v(" "),e("li",[a._v("CAS\n"),e("ul",[e("li",[a._v("什么是CAS")]),a._v(" "),e("li",[a._v("CAS使用示例")]),a._v(" "),e("li",[a._v("CAS 问题\n"),e("ul",[e("li",[a._v("ABA问题")]),a._v(" "),e("li",[a._v("循环时间长开销大")]),a._v(" "),e("li",[a._v("只能保证一个共享变量的原子操作")])])])])]),a._v(" "),e("li",[a._v("UnSafe类详解\n"),e("ul",[e("li",[a._v("Unsafe与CAS")]),a._v(" "),e("li",[a._v("Unsafe底层")]),a._v(" "),e("li",[a._v("Unsafe其它功能")])])]),a._v(" "),e("li",[a._v("AtomicInteger\n"),e("ul",[e("li",[a._v("使用举例")]),a._v(" "),e("li",[a._v("源码解析")])])]),a._v(" "),e("li",[a._v("延伸到所有原子类：共13个\n"),e("ul",[e("li",[a._v("原子更新基本类型")]),a._v(" "),e("li",[a._v("原子更新数组")]),a._v(" "),e("li",[a._v("原子更新引用类型")]),a._v(" "),e("li",[a._v("原子更新字段类")])])]),a._v(" "),e("li",[a._v("再讲讲AtomicStampedReference解决CAS的ABA问题\n"),e("ul",[e("li",[a._v("AtomicStampedReference解决ABA问题")]),a._v(" "),e("li",[a._v("使用举例")]),a._v(" "),e("li",[a._v("java中还有哪些类可以解决ABA的问题?")])])]),a._v(" "),e("li",[a._v("参考文章")])])])]),a._v(" "),e("h3",{attrs:{id:"带着bat大厂的面试问题去理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#带着bat大厂的面试问题去理解"}},[a._v("#")]),a._v(" # 带着BAT大厂的面试问题去理解")]),a._v(" "),e("blockquote",[e("p",[a._v("提示")])]),a._v(" "),e("blockquote",[e("p",[a._v("请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。@123")])]),a._v(" "),e("ul",[e("li",[a._v("线程安全的实现方法有哪些?")]),a._v(" "),e("li",[a._v("什么是CAS?")]),a._v(" "),e("li",[a._v("CAS使用示例，结合AtomicInteger给出示例?")]),a._v(" "),e("li",[a._v("CAS会有哪些问题?")]),a._v(" "),e("li",[a._v("针对这这些问题，Java提供了哪几个解决的?")]),a._v(" "),e("li",[a._v("AtomicInteger底层实现? CAS+volatile")]),a._v(" "),e("li",[a._v("请阐述你对Unsafe类的理解?")]),a._v(" "),e("li",[a._v("说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景。")]),a._v(" "),e("li",[a._v("AtomicStampedReference是什么?")]),a._v(" "),e("li",[a._v("AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号")]),a._v(" "),e("li",[a._v("java中还有哪些类可以解决ABA的问题? AtomicMarkableReference")])]),a._v(" "),e("h3",{attrs:{id:"cas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" # CAS")]),a._v(" "),e("blockquote",[e("p",[a._v("前面我们说到，线程安全的实现方法包含:")])]),a._v(" "),e("ul",[e("li",[a._v("互斥同步: synchronized 和 ReentrantLock")]),a._v(" "),e("li",[a._v("非阻塞同步: CAS, AtomicXXXX")]),a._v(" "),e("li",[a._v("无同步方案: 栈封闭，Thread Local，可重入代码")])]),a._v(" "),e("blockquote",[e("p",[a._v("具体可以参看：线程安全的实现方法，这里我们将对CAS重点阐释。")])]),a._v(" "),e("h3",{attrs:{id:"什么是cas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是cas"}},[a._v("#")]),a._v(" # 什么是CAS")]),a._v(" "),e("blockquote",[e("p",[a._v("CAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。   简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。")])]),a._v(" "),e("blockquote",[e("p",[a._v("CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。")])]),a._v(" "),e("blockquote",[e("p",[a._v("相信sql大家都熟悉，类似sql中的条件更新一样：update set id=3 from table where id=2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功。")])]),a._v(" "),e("h3",{attrs:{id:"cas使用示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cas使用示例"}},[a._v("#")]),a._v(" # CAS使用示例")]),a._v(" "),e("blockquote",[e("p",[a._v("如果不使用CAS，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的)。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public class Test {\n    private int i=0;\n    public synchronized int add(){\n        return i++;\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("blockquote",[e("p",[a._v("java中为我们提供了AtomicInteger 原子类(底层基于CAS进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public class Test {\n    private  AtomicInteger i = new AtomicInteger(0);\n    public int add(){\n        return i.addAndGet(1);\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h3",{attrs:{id:"cas-问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cas-问题"}},[a._v("#")]),a._v(" # CAS 问题")]),a._v(" "),e("blockquote",[e("p",[a._v("CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。")])]),a._v(" "),e("blockquote",[e("p",[a._v("但使用 CAS 方式也会有几个问题：")])]),a._v(" "),e("h4",{attrs:{id:"aba问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aba问题"}},[a._v("#")]),a._v(" # ABA问题")]),a._v(" "),e("blockquote",[e("p",[a._v("因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。")])]),a._v(" "),e("blockquote",[e("p",[a._v("ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A->B->A就会变成1A->2B->3A。")])]),a._v(" "),e("blockquote",[e("p",[a._v("从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。")])]),a._v(" "),e("h4",{attrs:{id:"循环时间长开销大"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#循环时间长开销大"}},[a._v("#")]),a._v(" # 循环时间长开销大")]),a._v(" "),e("blockquote",[e("p",[a._v("自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。")])]),a._v(" "),e("h4",{attrs:{id:"只能保证一个共享变量的原子操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#只能保证一个共享变量的原子操作"}},[a._v("#")]),a._v(" # 只能保证一个共享变量的原子操作")]),a._v(" "),e("blockquote",[e("p",[a._v("当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。")])]),a._v(" "),e("blockquote",[e("p",[a._v("还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。")])]),a._v(" "),e("blockquote",[e("p",[a._v("从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。")])]),a._v(" "),e("h3",{attrs:{id:"unsafe类详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unsafe类详解"}},[a._v("#")]),a._v(" # UnSafe类详解")]),a._v(" "),e("blockquote",[e("blockquote",[e("p",[a._v("上文我们了解到Java原子类是通过UnSafe类实现的，这节主要分析下UnSafe类。UnSafe类在J.U.C中CAS操作有很广泛的应用。")])])]),a._v(" "),e("blockquote",[e("p",[a._v("Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再安全，因此对Unsafe的使用一定要慎重。")])]),a._v(" "),e("blockquote",[e("p",[a._v("这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。")])]),a._v(" "),e("blockquote",[e("p",[a._v("先来看下这张图，对UnSafe类总体功能：")])]),a._v(" "),e("blockquote",[e("p",[e("img",{attrs:{src:n(615),alt:""}})])]),a._v(" "),e("blockquote",[e("p",[a._v("如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。")])]),a._v(" "),e("h3",{attrs:{id:"unsafe与cas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unsafe与cas"}},[a._v("#")]),a._v(" # Unsafe与CAS")]),a._v(" "),e("blockquote",[e("p",[a._v("反编译出来的代码：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public final int getAndAddInt(Object paramObject, long paramLong, int paramInt)\n  {\n    int i;\n    do\n      i = getIntVolatile(paramObject, paramLong);\n    while (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));\n    return i;\n  }\n\n  public final long getAndAddLong(Object paramObject, long paramLong1, long paramLong2)\n  {\n    long l;\n    do\n      l = getLongVolatile(paramObject, paramLong1);\n    while (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2));\n    return l;\n  }\n\n  public final int getAndSetInt(Object paramObject, long paramLong, int paramInt)\n  {\n    int i;\n    do\n      i = getIntVolatile(paramObject, paramLong);\n    while (!compareAndSwapInt(paramObject, paramLong, i, paramInt));\n    return i;\n  }\n\n  public final long getAndSetLong(Object paramObject, long paramLong1, long paramLong2)\n  {\n    long l;\n    do\n      l = getLongVolatile(paramObject, paramLong1);\n    while (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2));\n    return l;\n  }\n\n  public final Object getAndSetObject(Object paramObject1, long paramLong, Object paramObject2)\n  {\n    Object localObject;\n    do\n      localObject = getObjectVolatile(paramObject1, paramLong);\n    while (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2));\n    return localObject;\n  }\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br"),e("span",{staticClass:"line-number"},[a._v("30")]),e("br"),e("span",{staticClass:"line-number"},[a._v("31")]),e("br"),e("span",{staticClass:"line-number"},[a._v("32")]),e("br"),e("span",{staticClass:"line-number"},[a._v("33")]),e("br"),e("span",{staticClass:"line-number"},[a._v("34")]),e("br"),e("span",{staticClass:"line-number"},[a._v("35")]),e("br"),e("span",{staticClass:"line-number"},[a._v("36")]),e("br"),e("span",{staticClass:"line-number"},[a._v("37")]),e("br"),e("span",{staticClass:"line-number"},[a._v("38")]),e("br"),e("span",{staticClass:"line-number"},[a._v("39")]),e("br"),e("span",{staticClass:"line-number"},[a._v("40")]),e("br"),e("span",{staticClass:"line-number"},[a._v("41")]),e("br"),e("span",{staticClass:"line-number"},[a._v("42")]),e("br"),e("span",{staticClass:"line-number"},[a._v("43")]),e("br"),e("span",{staticClass:"line-number"},[a._v("44")]),e("br")])]),e("blockquote",[e("p",[a._v("从源码中发现，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。")])]),a._v(" "),e("blockquote",[e("p",[a._v("又从Unsafe类中发现，原子操作其实只支持下面三个方法。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);\n\npublic final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);\n\npublic final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("blockquote",[e("p",[a._v("我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。")])]),a._v(" "),e("h3",{attrs:{id:"unsafe底层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unsafe底层"}},[a._v("#")]),a._v(" # Unsafe底层")]),a._v(" "),e("blockquote",[e("p",[a._v("不妨再看看Unsafe的compareAndSwap*方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper("Unsafe_CompareAndSwapInt");\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("blockquote",[e("p",[a._v("可以看到它通过 "),e("code",[a._v("Atomic::cmpxchg")]),a._v(" 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。")])]),a._v(" "),e("blockquote",[e("p",[a._v("如果是Linux的x86，"),e("code",[a._v("Atomic::cmpxchg")]),a._v("方法的实现如下：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n  int mp = os::is_MP();\n  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"\n                    : "=a" (exchange_value)\n                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)\n                    : "cc", "memory");\n  return exchange_value;\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("blockquote",[e("p",[a._v("而windows的x86的实现如下：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n    int mp = os::isMP(); //判断是否是多处理器\n    _asm {\n        mov edx, dest\n        mov ecx, exchange_value\n        mov eax, compare_value\n        LOCK_IF_MP(mp)\n        cmpxchg dword ptr [edx], ecx\n    }\n}\n\n// Adding a lock prefix to an instruction on MP machine\n// VC++ doesn't like the lock prefix to be on a single line\n// so we can't insert a label after the lock prefix.\n// By emitting a lock prefix, we can define a label after it.\n#define LOCK_IF_MP(mp) __asm cmp mp, 0  \\\\\n                       __asm je L0      \\\\\n                       __asm _emit 0xF0 \\\\\n                       __asm L0:\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br")])]),e("blockquote",[e("p",[a._v("如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。")])]),a._v(" "),e("blockquote",[e("blockquote",[e("p",[a._v("cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。")])])]),a._v(" "),e("h3",{attrs:{id:"unsafe其它功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unsafe其它功能"}},[a._v("#")]),a._v(" # Unsafe其它功能")]),a._v(" "),e("blockquote",[e("p",[a._v("Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。")])]),a._v(" "),e("blockquote",[e("p",[a._v("举两个例子，比方说：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public native long staticFieldOffset(Field paramField);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("blockquote",[e("p",[a._v("这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。")])]),a._v(" "),e("blockquote",[e("p",[a._v("再比如说：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public native int arrayBaseOffset(Class paramClass);\npublic native int arrayIndexScale(Class paramClass);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("blockquote",[e("p",[a._v("前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。")])]),a._v(" "),e("blockquote",[e("p",[a._v("最后看三个方法：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public native long allocateMemory(long paramLong);\npublic native long reallocateMemory(long paramLong1, long paramLong2);\npublic native void freeMemory(long paramLong);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("blockquote",[e("p",[a._v("分别用来分配内存，扩充内存和释放内存的。")])]),a._v(" "),e("blockquote",[e("blockquote",[e("p",[a._v("更多相关功能，推荐你看下这篇文章：来自美团技术团队：Java魔法类：Unsafe应用解析在新窗口打开")])])]),a._v(" "),e("h3",{attrs:{id:"atomicinteger"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#atomicinteger"}},[a._v("#")]),a._v(" # AtomicInteger")]),a._v(" "),e("h3",{attrs:{id:"使用举例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用举例"}},[a._v("#")]),a._v(" # 使用举例")]),a._v(" "),e("blockquote",[e("p",[a._v("以 AtomicInteger 为例，常用 API：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public final int get()：获取当前的值\npublic final int getAndSet(int newValue)：获取当前的值，并设置新的值\npublic final int getAndIncrement()：获取当前的值，并自增\npublic final int getAndDecrement()：获取当前的值，并自减\npublic final int getAndAdd(int delta)：获取当前的值，并加上预期的值\nvoid lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("blockquote",[e("p",[a._v("相比 Integer 的优势，多线程中让变量自增：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("private volatile int count = 0;\n// 若要线程安全执行执行 count++，需要加锁\npublic synchronized void increment() {\n    count++;\n}\npublic int getCount() {\n    return count;\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("blockquote",[e("p",[a._v("使用 AtomicInteger 后：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("private AtomicInteger count = new AtomicInteger();\npublic void increment() {\n    count.incrementAndGet();\n}\n// 使用 AtomicInteger 后，不需要加锁，也可以实现线程安全\npublic int getCount() {\n    return count.get();\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("h3",{attrs:{id:"源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[a._v("#")]),a._v(" # 源码解析")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('public class AtomicInteger extends Number implements java.io.Serializable {\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n    static {\n        try {\n            //用于获取value字段相对当前对象的“起始地址”的偏移量\n            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n    //返回当前值\n    public final int get() {\n        return value;\n    }\n\n    //递增加detla\n    public final int getAndAdd(int delta) {\n        //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n\n    //递增加1\n    public final int incrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n    }\n...\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br")])]),e("blockquote",[e("p",[a._v("我们可以看到 AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。")])]),a._v(" "),e("ul",[e("li",[a._v("volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值")]),a._v(" "),e("li",[a._v("CAS 保证数据更新的原子性。")])]),a._v(" "),e("h3",{attrs:{id:"延伸到所有原子类-共12个"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#延伸到所有原子类-共12个"}},[a._v("#")]),a._v(" # 延伸到所有原子类：共12个")]),a._v(" "),e("blockquote",[e("blockquote",[e("p",[a._v("JDK中提供了12个原子操作类。")])])]),a._v(" "),e("h3",{attrs:{id:"原子更新基本类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子更新基本类型"}},[a._v("#")]),a._v(" # 原子更新基本类型")]),a._v(" "),e("blockquote",[e("p",[a._v("使用原子的方式更新基本类型，Atomic包提供了以下3个类。")])]),a._v(" "),e("ul",[e("li",[a._v("AtomicBoolean: 原子更新布尔类型。")]),a._v(" "),e("li",[a._v("AtomicInteger: 原子更新整型。")]),a._v(" "),e("li",[a._v("AtomicLong: 原子更新长整型。")])]),a._v(" "),e("blockquote",[e("p",[a._v("以上3个类提供的方法几乎一模一样，可以参考上面AtomicInteger中的相关方法。")])]),a._v(" "),e("h3",{attrs:{id:"原子更新数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子更新数组"}},[a._v("#")]),a._v(" # 原子更新数组")]),a._v(" "),e("blockquote",[e("p",[a._v("通过原子的方式更新数组里的某个元素，Atomic包提供了以下的3个类：")])]),a._v(" "),e("ul",[e("li",[a._v("AtomicIntegerArray: 原子更新整型数组里的元素。")]),a._v(" "),e("li",[a._v("AtomicLongArray: 原子更新长整型数组里的元素。")]),a._v(" "),e("li",[a._v("AtomicReferenceArray: 原子更新引用类型数组里的元素。")])]),a._v(" "),e("blockquote",[e("p",[a._v("这三个类的最常用的方法是如下两个方法：")])]),a._v(" "),e("ul",[e("li",[a._v("get(int index)：获取索引为index的元素值。")]),a._v(" "),e("li",[a._v("compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。")])]),a._v(" "),e("blockquote",[e("p",[a._v("举个AtomicIntegerArray例子：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import java.util.concurrent.atomic.AtomicIntegerArray;\n\npublic class Demo5 {\n    public static void main(String[] args) throws InterruptedException {\n        AtomicIntegerArray array = new AtomicIntegerArray(new int[] { 0, 0 });\n        System.out.println(array);\n        System.out.println(array.getAndAdd(1, 2));\n        System.out.println(array);\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br")])]),e("blockquote",[e("p",[a._v("输出结果：")])]),a._v(" "),e("p",[e("code",[a._v("[0, 0] 0 [0, 2]")])]),a._v(" "),e("h3",{attrs:{id:"原子更新引用类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子更新引用类型"}},[a._v("#")]),a._v(" # 原子更新引用类型")]),a._v(" "),e("blockquote",[e("p",[a._v("Atomic包提供了以下三个类：")])]),a._v(" "),e("ul",[e("li",[a._v("AtomicReference: 原子更新引用类型。")]),a._v(" "),e("li",[a._v("AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。")]),a._v(" "),e("li",[a._v("AtomicMarkableReferce: 原子更新带有标记位的引用类型。")])]),a._v(" "),e("blockquote",[e("p",[a._v("这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用compareAndSet等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰。")])]),a._v(" "),e("blockquote",[e("p",[a._v("举个AtomicReference例子：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('import java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceTest {\n\n    public static void main(String[] args){\n\n        // 创建两个Person对象，它们的id分别是101和102。\n        Person p1 = new Person(101);\n        Person p2 = new Person(102);\n        // 新建AtomicReference对象，初始化它的值为p1对象\n        AtomicReference ar = new AtomicReference(p1);\n        // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。\n        ar.compareAndSet(p1, p2);\n\n        Person p3 = (Person)ar.get();\n        System.out.println("p3 is "+p3);\n        System.out.println("pequals(p1)="+pequals(p1));\n    }\n}\n\nclass Person {\n    volatile long id;\n    public Person(long id) {\n        this.id = id;\n    }\n    public String toString() {\n        return "id:"+id;\n    }\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br")])]),e("blockquote",[e("p",[a._v("结果输出：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("p3 is id:102\npequals(p1)=false\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("blockquote",[e("p",[a._v("结果说明：")])]),a._v(" "),e("ul",[e("li",[a._v("新建AtomicReference对象ar时，将它初始化为p1。")]),a._v(" "),e("li",[a._v("紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。")]),a._v(" "),e("li",[a._v('最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用"=="去比较两个对象，即比较两个对象的地址是否相等。')])]),a._v(" "),e("h3",{attrs:{id:"原子更新字段类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子更新字段类"}},[a._v("#")]),a._v(" # 原子更新字段类")]),a._v(" "),e("blockquote",[e("p",[a._v("Atomic包提供了四个类进行原子字段更新：")])]),a._v(" "),e("ul",[e("li",[a._v("AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。")]),a._v(" "),e("li",[a._v("AtomicLongFieldUpdater: 原子更新长整型字段的更新器。")]),a._v(" "),e("li",[a._v("AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。")])]),a._v(" "),e("blockquote",[e("p",[a._v("这四个类的使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:")])]),a._v(" "),e("ul",[e("li",[a._v("第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。")]),a._v(" "),e("li",[a._v("第二步，更新类的字段必须使用public volatile修饰。")])]),a._v(" "),e("blockquote",[e("p",[a._v("举个例子：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('public class TestAtomicIntegerFieldUpdater {\n\n    public static void main(String[] args){\n        TestAtomicIntegerFieldUpdater tIA = new TestAtomicIntegerFieldUpdater();\n        tIA.doIt();\n    }\n\n    public AtomicIntegerFieldUpdater<DataDemo> updater(String name){\n        return AtomicIntegerFieldUpdater.newUpdater(DataDemo.class,name);\n\n    }\n\n    public void doIt(){\n        DataDemo data = new DataDemo();\n        System.out.println("publicVar = "+updater("publicVar").getAndAdd(data, 2));\n        /*\n            * 由于在DataDemo类中属性value2/value3,在TestAtomicIntegerFieldUpdater中不能访问\n            * */\n        //System.out.println("protectedVar = "+updater("protectedVar").getAndAdd(data,2));\n        //System.out.println("privateVar = "+updater("privateVar").getAndAdd(data,2));\n\n        //System.out.println("staticVar = "+updater("staticVar").getAndIncrement(data));//报java.lang.IllegalArgumentException\n        /*\n            * 下面报异常：must be integer\n            * */\n        //System.out.println("integerVar = "+updater("integerVar").getAndIncrement(data));\n        //System.out.println("longVar = "+updater("longVar").getAndIncrement(data));\n    }\n\n}\n\nclass DataDemo{\n    public volatile int publicVar=3;\n    protected volatile int protectedVar=4;\n    private volatile  int privateVar=5;\n\n    public volatile static int staticVar = 10;\n    //public  final int finalVar = 11;\n\n    public volatile Integer integerVar = 19;\n    public volatile Long longVar = 18L;\n\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br"),e("span",{staticClass:"line-number"},[a._v("30")]),e("br"),e("span",{staticClass:"line-number"},[a._v("31")]),e("br"),e("span",{staticClass:"line-number"},[a._v("32")]),e("br"),e("span",{staticClass:"line-number"},[a._v("33")]),e("br"),e("span",{staticClass:"line-number"},[a._v("34")]),e("br"),e("span",{staticClass:"line-number"},[a._v("35")]),e("br"),e("span",{staticClass:"line-number"},[a._v("36")]),e("br"),e("span",{staticClass:"line-number"},[a._v("37")]),e("br"),e("span",{staticClass:"line-number"},[a._v("38")]),e("br"),e("span",{staticClass:"line-number"},[a._v("39")]),e("br"),e("span",{staticClass:"line-number"},[a._v("40")]),e("br"),e("span",{staticClass:"line-number"},[a._v("41")]),e("br"),e("span",{staticClass:"line-number"},[a._v("42")]),e("br"),e("span",{staticClass:"line-number"},[a._v("43")]),e("br")])]),e("blockquote",[e("p",[a._v("再说下对于AtomicIntegerFieldUpdater 的使用稍微有一些限制和约束，约束如下：")])]),a._v(" "),e("ul",[e("li",[e("blockquote",[e("p",[a._v("字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value = 3")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("字段的描述类型(修饰符public/protected/default/private)是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("只能是实例变量，不能是类变量，也就是说不能加static关键字。")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型(Integer/Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。")])])])]),a._v(" "),e("h3",{attrs:{id:"再讲讲atomicstampedreference解决cas的aba问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再讲讲atomicstampedreference解决cas的aba问题"}},[a._v("#")]),a._v(" # 再讲讲AtomicStampedReference解决CAS的ABA问题")]),a._v(" "),e("h3",{attrs:{id:"atomicstampedreference解决aba问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#atomicstampedreference解决aba问题"}},[a._v("#")]),a._v(" # AtomicStampedReference解决ABA问题")]),a._v(" "),e("blockquote",[e("p",[a._v('AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数"stamp"的pair对象来解决ABA问题。')])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("public class AtomicStampedReference<V> {\n    private static class Pair<T> {\n        final T reference;  //维护对象引用\n        final int stamp;  //用于标志版本\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n    private volatile Pair<V> pair;\n    ....\n\n    /**\n      * expectedReference ：更新之前的原始值\n      * newReference : 将要更新的新值\n      * expectedStamp : 期待更新的标志版本\n      * newStamp : 将要更新的标志版本\n      */\n    public boolean compareAndSet(V   expectedReference,\n                             V   newReference,\n                             int expectedStamp,\n                             int newStamp) {\n        // 获取当前的(元素值，版本号)对\n        Pair<V> current = pair;\n        return\n            // 引用没变\n            expectedReference == current.reference &&\n            // 版本号没变\n            expectedStamp == current.stamp &&\n            // 新引用等于旧引用\n            ((newReference == current.reference &&\n            // 新版本号等于旧版本号\n            newStamp == current.stamp) ||\n            // 构造新的Pair对象并CAS更新\n            casPair(current, Pair.of(newReference, newStamp)));\n    }\n\n    private boolean casPair(Pair<V> cmp, Pair<V> val) {\n        // 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用\n        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n    }\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br"),e("span",{staticClass:"line-number"},[a._v("30")]),e("br"),e("span",{staticClass:"line-number"},[a._v("31")]),e("br"),e("span",{staticClass:"line-number"},[a._v("32")]),e("br"),e("span",{staticClass:"line-number"},[a._v("33")]),e("br"),e("span",{staticClass:"line-number"},[a._v("34")]),e("br"),e("span",{staticClass:"line-number"},[a._v("35")]),e("br"),e("span",{staticClass:"line-number"},[a._v("36")]),e("br"),e("span",{staticClass:"line-number"},[a._v("37")]),e("br"),e("span",{staticClass:"line-number"},[a._v("38")]),e("br"),e("span",{staticClass:"line-number"},[a._v("39")]),e("br"),e("span",{staticClass:"line-number"},[a._v("40")]),e("br"),e("span",{staticClass:"line-number"},[a._v("41")]),e("br"),e("span",{staticClass:"line-number"},[a._v("42")]),e("br"),e("span",{staticClass:"line-number"},[a._v("43")]),e("br"),e("span",{staticClass:"line-number"},[a._v("44")]),e("br")])]),e("ul",[e("li",[e("blockquote",[e("p",[a._v("如果元素值和版本号都没有变化，并且和新的也相同，返回true；")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。")])])])]),a._v(" "),e("blockquote",[e("p",[a._v("可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。")])]),a._v(" "),e("ul",[e("li",[e("blockquote",[e("p",[a._v("首先，使用版本号控制；")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；")])])]),a._v(" "),e("li",[e("blockquote",[e("p",[a._v("最后，外部传入元素值及版本号，而不是节点(Pair)的引用。")])])])]),a._v(" "),e("h3",{attrs:{id:"使用举例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用举例-2"}},[a._v("#")]),a._v(" # 使用举例")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('public class AtomicTester {\n\n    private static AtomicStampedReference<Integer> atomicStampedRef =\n            new AtomicStampedReference<>(1, 0);\n\n    public static void main(String[] args){\n        first().start();\n        second().start();\n    }\n\n    private static Thread first() {\n        return new Thread(() -> {\n            System.out.println("操作线程" + Thread.currentThread() +",初始值 a = " + atomicStampedRef.getReference());\n            int stamp = atomicStampedRef.getStamp(); //获取当前标识别\n            try {\n                Thread.sleep(1000); //等待1秒 ，以便让干扰线程执行\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean isCASSuccess = atomicStampedRef.compareAndSet(1,2,stamp,stamp +1);  //此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败\n            System.out.println("操作线程" + Thread.currentThread() +",CAS操作结果: " + isCASSuccess);\n        },"主操作线程");\n    }\n\n    private static Thread second() {\n        return new Thread(() -> {\n            Thread.yield(); // 确保thread-first 优先执行\n            atomicStampedRef.compareAndSet(1,2,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1);\n            System.out.println("操作线程" + Thread.currentThread() +",【increment】 ,值 = "+ atomicStampedRef.getReference());\n            atomicStampedRef.compareAndSet(2,1,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1);\n            System.out.println("操作线程" + Thread.currentThread() +",【decrement】 ,值 = "+ atomicStampedRef.getReference());\n        },"干扰线程");\n    }\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br"),e("span",{staticClass:"line-number"},[a._v("30")]),e("br"),e("span",{staticClass:"line-number"},[a._v("31")]),e("br"),e("span",{staticClass:"line-number"},[a._v("32")]),e("br"),e("span",{staticClass:"line-number"},[a._v("33")]),e("br"),e("span",{staticClass:"line-number"},[a._v("34")]),e("br")])]),e("blockquote",[e("p",[a._v("输出结果：")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("操作线程Thread[主操作线程,5,main],初始值 a = 1\n操作线程Thread[干扰线程,5,main],【increment】 ,值 = 2\n操作线程Thread[干扰线程,5,main],【decrement】 ,值 = 1\n操作线程Thread[主操作线程,5,main],CAS操作结果: false\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("h3",{attrs:{id:"java中还有哪些类可以解决aba的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java中还有哪些类可以解决aba的问题"}},[a._v("#")]),a._v(" # java中还有哪些类可以解决ABA的问题?")]),a._v(" "),e("blockquote",[e("p",[a._v("AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。")])]),a._v(" "),e("h3",{attrs:{id:"参考文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" # 参考文章")]),a._v(" "),e("ul",[e("li",[a._v("https://benjaminwhx.com/2018/05/03/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88CAS/")]),a._v(" "),e("li",[a._v("https://www.jianshu.com/p/9a1e6940987a")]),a._v(" "),e("li",[a._v("https://www.jianshu.com/p/a533cbb740c6")]),a._v(" "),e("li",[a._v("https://blog.csdn.net/qq_36236890/article/details/81914871")]),a._v(" "),e("li",[a._v("https://www.cnblogs.com/lodor/p/7492805.html")]),a._v(" "),e("li",[a._v("https://blog.csdn.net/u010412719/article/details/52068888")]),a._v(" "),e("li",[a._v("https://www.jianshu.com/p/18dfc5fa0171")]),a._v(" "),e("li",[a._v("https://www.jianshu.com/p/8b227a8adbc1")]),a._v(" "),e("li",[a._v("https://www.jianshu.com/p/77f75b398be9")]),a._v(" "),e("li",[a._v("https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html")])])])}),[],!1,null,null,null);e.default=t.exports}}]);