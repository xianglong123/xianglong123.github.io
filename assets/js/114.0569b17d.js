(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{799:function(a,n,e){"use strict";e.r(n);var s=e(0),t=Object(s.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"java-并发-threadlocal详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-并发-threadlocal详解"}},[a._v("#")]),a._v(" Java 并发 - ThreadLocal详解")]),a._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),n("p",[a._v("请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 @123")])]),a._v(" "),n("ul",[n("li",[a._v("什么是ThreadLocal? 用来解决什么问题的?")]),a._v(" "),n("li",[a._v("说说你对ThreadLocal的理解")]),a._v(" "),n("li",[a._v("ThreadLocal是如何实现线程隔离的?")]),a._v(" "),n("li",[a._v("为什么ThreadLocal会造成内存泄露? 如何解决")]),a._v(" "),n("li",[a._v("还有哪些使用ThreadLocal的应用场景?")])]),a._v(" "),n("h3",{attrs:{id:"threadlocal简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal简介"}},[a._v("#")]),a._v(" # ThreadLocal简介")]),a._v(" "),n("blockquote",[n("p",[a._v("我们在Java 并发 - 并发理论基础总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：")])]),a._v(" "),n("ul",[n("li",[a._v("互斥同步: synchronized 和 ReentrantLock")]),a._v(" "),n("li",[a._v("非阻塞同步: CAS, AtomicXXXX")]),a._v(" "),n("li",[a._v("无同步方案: 栈封闭，本地存储(Thread Local)，可重入代码")])]),a._v(" "),n("blockquote",[n("p",[a._v("这个章节将详细的讲讲 本地存储(Thread Local)。官网的解释是这样的：")])]),a._v(" "),n("blockquote",[n("blockquote",[n("p",[a._v("This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID) 该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。")])])]),a._v(" "),n("blockquote",[n("p",[a._v("总结而言：ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。")])]),a._v(" "),n("h3",{attrs:{id:"threadlocal理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal理解"}},[a._v("#")]),a._v(" # ThreadLocal理解")]),a._v(" "),n("blockquote",[n("blockquote",[n("p",[a._v("提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解ThreadLocal：")])])]),a._v(" "),n("ul",[n("li",[a._v("如下数据库管理类在单线程使用是没有任何问题的")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("class ConnectionManager {\n    private static Connection connect = null;\n\n    public static Connection openConnection() {\n        if (connect == null) {\n            connect = DriverManager.getConnection();\n        }\n        return connect;\n    }\n\n    public static void closeConnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br")])]),n("blockquote",[n("p",[a._v("很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。")])]),a._v(" "),n("ul",[n("li",[a._v("为了解决上述线程安全的问题，第一考虑：互斥同步")])]),a._v(" "),n("blockquote",[n("p",[a._v("你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。")])]),a._v(" "),n("ul",[n("li",[a._v("这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?")])]),a._v(" "),n("blockquote",[n("p",[a._v("事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("class ConnectionManager {\n    private Connection connect = null;\n\n    public Connection openConnection() {\n        if (connect == null) {\n            connect = DriverManager.getConnection();\n        }\n        return connect;\n    }\n\n    public void closeConnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n\nclass Dao {\n    public void insert() {\n        ConnectionManager connectionManager = new ConnectionManager();\n        Connection connection = connectionManager.openConnection();\n\n        // 使用connection进行操作\n\n        connectionManager.closeConnection();\n    }\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br")])]),n("blockquote",[n("p",[a._v("这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。")])]),a._v(" "),n("ul",[n("li",[a._v("这时候ThreadLocal登场了")])]),a._v(" "),n("blockquote",[n("p",[a._v("那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class ConnectionManager {\n\n    private static final ThreadLocal<Connection> dbConnectionLocal = new ThreadLocal<Connection>() {\n        @Override\n        protected Connection initialValue() {\n            try {\n                return DriverManager.getConnection("", "", "");\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n    };\n\n    public Connection getConnection() {\n        return dbConnectionLocal.get();\n    }\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br")])]),n("ul",[n("li",[a._v("再注意下ThreadLocal的修饰符")])]),a._v(" "),n("blockquote",[n("p",[a._v("ThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。")])]),a._v(" "),n("blockquote",[n("blockquote",[n("p",[a._v("但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。")])])]),a._v(" "),n("h3",{attrs:{id:"threadlocal原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal原理"}},[a._v("#")]),a._v(" # ThreadLocal原理")]),a._v(" "),n("h3",{attrs:{id:"如何实现线程隔离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何实现线程隔离"}},[a._v("#")]),a._v(" # 如何实现线程隔离")]),a._v(" "),n("blockquote",[n("p",[a._v("主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals, 负责存储当前线程的关于Connection的对象, dbConnectionLocal(以上述例子中为例) 这个变量为Key, 以新建的Connection对象为Value; 这样的话, 线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回;")])]),a._v(" "),n("blockquote",[n("p",[a._v("具体关于为线程分配变量副本的代码如下:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('public T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap threadLocals = getMap(t);\n    if (threadLocals != null) {\n        ThreadLocalMap.Entry e = threadLocals.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br")])]),n("ul",[n("li",[a._v("首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals")]),a._v(" "),n("li",[a._v("如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);")]),a._v(" "),n("li",[a._v("如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回")]),a._v(" "),n("li",[a._v("如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。")])]),a._v(" "),n("blockquote",[n("p",[a._v("如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("private T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br")])]),n("ul",[n("li",[n("blockquote",[n("p",[a._v("首先调用我们上面写的重载过后的initialValue方法, 产生一个Connection对象")])])]),a._v(" "),n("li",[n("blockquote",[n("p",[a._v("继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;")])])])]),a._v(" "),n("blockquote",[n("p",[a._v("同时, ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br")])]),n("blockquote",[n("p",[a._v("这样我们也可以不实现initialValue, 将初始化工作放到DBConnectionFactory的getConnection方法中:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('public Connection getConnection() {\n    Connection connection = dbConnectionLocal.get();\n    if (connection == null) {\n        try {\n            connection = DriverManager.getConnection("", "", "");\n            dbConnectionLocal.set(connection);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    return connection;\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br")])]),n("blockquote",[n("p",[a._v("那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了; 其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;")])]),a._v(" "),n("blockquote",[n("p",[a._v("当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了;")])]),a._v(" "),n("blockquote",[n("p",[a._v("现在我们知道了ThreadLocal到底是什么了, 又知道了如何使用ThreadLocal以及其基本实现原理了是不是就可以结束了呢? 其实还有一个问题就是ThreadLocalMap是个什么对象, 为什么要用这个对象呢?")])]),a._v(" "),n("h3",{attrs:{id:"threadlocalmap对象是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadlocalmap对象是什么"}},[a._v("#")]),a._v(" # ThreadLocalMap对象是什么")]),a._v(" "),n("blockquote",[n("p",[a._v("本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样")])]),a._v(" "),n("ul",[n("li",[a._v("它没有实现Map接口;")]),a._v(" "),n("li",[a._v("它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类")]),a._v(" "),n("li",[a._v("ThreadLocalMap的Entry实现继承了WeakReference<ThreadLocal<?>>")]),a._v(" "),n("li",[a._v("该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;")])]),a._v(" "),n("blockquote",[n("p",[a._v("要了解ThreadLocalMap的实现, 我们先从入口开始, 就是往该Map中添加一个值:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("private void set(ThreadLocal<?> key, Object value) {\n\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br")])]),n("blockquote",[n("p",[a._v("先进行简单的分析, 对该代码表层意思进行解读:")])]),a._v(" "),n("ul",[n("li",[a._v("看下当前threadLocal的在数组中的索引位置 比如: "),n("code",[a._v("i = 2")]),a._v(", 看 "),n("code",[a._v("i = 2")]),a._v(" 位置上面的元素(Entry)的"),n("code",[a._v("Key")]),a._v("是否等于threadLocal 这个 Key, 如果等于就很好说了, 直接将该位置上面的Entry的Value替换成最新的就可以了;")]),a._v(" "),n("li",[a._v("如果当前位置上面的 Entry 的 Key为空, 说明ThreadLocal对象已经被回收了, 那么就调用replaceStaleEntry")]),a._v(" "),n("li",[a._v("如果清理完无用条目(ThreadLocal被回收的条目)、并且数组中的数据大小 > 阈值的时候对当前的Table进行重新哈希 所以, 该HashMap是处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置;")])]),a._v(" "),n("blockquote",[n("p",[a._v("了解完Set方法, 后面就是Get方法了:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("private Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br")])]),n("blockquote",[n("p",[a._v("先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。")])]),a._v(" "),n("h3",{attrs:{id:"threadlocal造成内存泄露的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal造成内存泄露的问题"}},[a._v("#")]),a._v(" # ThreadLocal造成内存泄露的问题")]),a._v(" "),n("blockquote",[n("p",[a._v("网上有这样一个例子：")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('import java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadLocalDemo {\n    static class LocalVariable {\n        private Long[] a = new Long[1024 * 1024];\n    }\n\n    // (1)\n    final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,\n            new LinkedBlockingQueue<>());\n    // (2)\n    final static ThreadLocal<LocalVariable> localVariable = new ThreadLocal<LocalVariable>();\n\n    public static void main(String[] args) throws InterruptedException {\n        // (3)\n        Thread.sleep(5000 * 4);\n        for (int i = 0; i < 50; ++i) {\n            poolExecutor.execute(new Runnable() {\n                public void run() {\n                    // (4)\n                    localVariable.set(new LocalVariable());\n                    // (5)\n                    System.out.println("use local varaible" + localVariable.get());\n                    localVariable.remove();\n                }\n            });\n        }\n        // (6)\n        System.out.println("pool execute over");\n    }\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br")])]),n("blockquote",[n("p",[a._v("如果用线程池来操作ThreadLocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("<ThreadLocal, LocalVariable>\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("p",[a._v("的强引用, 因为final static 修饰的 ThreadLocal 并不会释放, 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露; 如果LocalVariable对象不是一个大对象的话, 其实泄露的并不严重,")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("泄露的内存 = 核心线程数 * LocalVariable\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("p",[a._v("对象的大小;")]),a._v(" "),n("blockquote",[n("p",[a._v("所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("private void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br")])]),n("blockquote",[n("p",[a._v("找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。")])]),a._v(" "),n("h3",{attrs:{id:"再看threadlocal应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#再看threadlocal应用场景"}},[a._v("#")]),a._v(" # 再看ThreadLocal应用场景")]),a._v(" "),n("blockquote",[n("p",[a._v("除了上述的数据库管理类的例子，我们再看看其它一些应用：")])]),a._v(" "),n("h3",{attrs:{id:"每个线程维护了一个-序列号"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#每个线程维护了一个-序列号"}},[a._v("#")]),a._v(" # 每个线程维护了一个“序列号”")]),a._v(" "),n("blockquote",[n("blockquote",[n("p",[a._v("再回想上文说的，如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。")])])]),a._v(" "),n("blockquote",[n("p",[a._v("每个线程维护了一个序列号")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public class SerialNum {\n    // The next serial number to be assigned\n    private static int nextSerialNum = 0;\n\n    private static ThreadLocal serialNum = new ThreadLocal() {\n        protected synchronized Object initialValue() {\n            return new Integer(nextSerialNum++);\n        }\n    };\n\n    public static int get() {\n        return ((Integer) (serialNum.get())).intValue();\n    }\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br")])]),n("h3",{attrs:{id:"session的管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#session的管理"}},[a._v("#")]),a._v(" # Session的管理")]),a._v(" "),n("blockquote",[n("p",[a._v("经典的另外一个例子：")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("private static final ThreadLocal threadSession = new ThreadLocal();  \n\npublic static Session getSession() throws InfrastructureException {  \n    Session s = (Session) threadSession.get();  \n    try {  \n        if (s == null) {  \n            s = getSessionFactory().openSession();  \n            threadSession.set(s);  \n        }  \n    } catch (HibernateException ex) {  \n        throw new InfrastructureException(ex);  \n    }  \n    return s;  \n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br")])]),n("h3",{attrs:{id:"在线程内部创建threadlocal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在线程内部创建threadlocal"}},[a._v("#")]),a._v(" # 在线程内部创建ThreadLocal")]),a._v(" "),n("blockquote",[n("p",[a._v("还有一种用法是在线程类内部创建ThreadLocal，基本步骤如下：")])]),a._v(" "),n("ul",[n("li",[a._v("在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。")]),a._v(" "),n("li",[a._v("在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。")]),a._v(" "),n("li",[a._v("在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('public class ThreadLocalTest implements Runnable{\n\n    ThreadLocal<Student> StudentThreadLocal = new ThreadLocal<Student>();\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + " is running...");\n        Random random = new Random();\n        int age = random.nextInt(100);\n        System.out.println(currentThreadName + " is set age: "  + age);\n        Student Student = getStudentt(); //通过这个方法，为每个线程都独立的new一个Studentt对象，每个线程的的Studentt对象都可以设置不同的值\n        Student.setAge(age);\n        System.out.println(currentThreadName + " is first get age: " + Student.getAge());\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println( currentThreadName + " is second get age: " + Student.getAge());\n\n    }\n\n    private Student getStudentt() {\n        Student Student = StudentThreadLocal.get();\n        if (null == Student) {\n            Student = new Student();\n            StudentThreadLocal.set(Student);\n        }\n        return Student;\n    }\n\n    public static void main(String[] args) {\n        ThreadLocalTest t = new ThreadLocalTest();\n        Thread t1 = new Thread(t,"Thread A");\n        Thread t2 = new Thread(t,"Thread B");\n        tstart();\n        tstart();\n    }\n\n}\n\nclass Student{\n    int age;\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br"),n("span",{staticClass:"line-number"},[a._v("34")]),n("br"),n("span",{staticClass:"line-number"},[a._v("35")]),n("br"),n("span",{staticClass:"line-number"},[a._v("36")]),n("br"),n("span",{staticClass:"line-number"},[a._v("37")]),n("br"),n("span",{staticClass:"line-number"},[a._v("38")]),n("br"),n("span",{staticClass:"line-number"},[a._v("39")]),n("br"),n("span",{staticClass:"line-number"},[a._v("40")]),n("br"),n("span",{staticClass:"line-number"},[a._v("41")]),n("br"),n("span",{staticClass:"line-number"},[a._v("42")]),n("br"),n("span",{staticClass:"line-number"},[a._v("43")]),n("br"),n("span",{staticClass:"line-number"},[a._v("44")]),n("br"),n("span",{staticClass:"line-number"},[a._v("45")]),n("br"),n("span",{staticClass:"line-number"},[a._v("46")]),n("br"),n("span",{staticClass:"line-number"},[a._v("47")]),n("br"),n("span",{staticClass:"line-number"},[a._v("48")]),n("br"),n("span",{staticClass:"line-number"},[a._v("49")]),n("br"),n("span",{staticClass:"line-number"},[a._v("50")]),n("br"),n("span",{staticClass:"line-number"},[a._v("51")]),n("br"),n("span",{staticClass:"line-number"},[a._v("52")]),n("br")])]),n("h3",{attrs:{id:"java-开发手册中推荐的-threadlocal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-开发手册中推荐的-threadlocal"}},[a._v("#")]),a._v(" # java 开发手册中推荐的 ThreadLocal")]),a._v(" "),n("blockquote",[n("p",[a._v("看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n \npublic class DateUtils {\n    public static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>(){\n        @Override\n        protected DateFormat initialValue() {\n            return new SimpleDateFormat("yyyy-MM-dd");\n        }\n    };\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br")])]),n("blockquote",[n("p",[a._v("然后我们再要用到 DateFormat 对象的地方，这样调用：")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("DateUtils.df.get().format(new Date());\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h3",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" # 参考文章")]),a._v(" "),n("ul",[n("li",[a._v("https://blog.csdn.net/vking_wang/article/details/14225379")]),a._v(" "),n("li",[a._v("https://mp.weixin.qq.com/s/mo3-y-45_ao54b5T7ez7iA")]),a._v(" "),n("li",[a._v("https://www.xttblog.com/?p=3087")]),a._v(" "),n("li",[a._v("https://blog.csdn.net/whut2010hj/article/details/81413887")]),a._v(" "),n("li",[a._v("https://segmentfault.com/a/1190000018399795")])])])}),[],!1,null,null,null);n.default=t.exports}}]);